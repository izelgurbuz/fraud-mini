

# ğŸ§¾ Debug & Architecture Evolution Diary â€” *fraudmini Event-Driven Pipeline*

## âš™ï¸ Context

I built a **serverless ingestion pipeline** on AWS where uploading a CSV to S3 should automatically trigger a chain of Lambdas:

```
S3 (RawEventsBucket)
   â†’ SQS (RawEventsQueue)
       â†’ Lambda: BatchIngest
           â†’ SQS (TransactionsQueue)
               â†’ Lambda: ScoreFunction
```

Each stage processes data asynchronously â€” the goal was to parse CSVs, validate transactions, push them through scoring logic, and store receipts in a separate `RefinedEventsBucket`.

---

## ğŸ©¸ First Attempt â€“ Direct S3 â†’ Lambda Trigger

### What I tried

Initially, I wanted S3 to directly trigger **BatchIngestFunction** whenever I uploaded a CSV file under `inbox/`.

**Flow I aimed for:**

1. Upload CSV â†’ triggers BatchIngest.
2. BatchIngest reads the CSV from the same bucket.
3. It processes records, creates a receipt JSON, moves the file to `/processed/`, and sends transactions directly to **ScoreFunction**.

### What went wrong

* I hit **circular dependency errors** because both the bucket and the Lambda referenced each other.
* The Lambda was both *triggered by* and *writing to* the same bucket â€” meaning every write operation could re-trigger itself.
* CloudFormation failed due to the dependency loop (`BucketPolicy â†” LambdaRole â†” Function`).
* The design was fragile and not scalable â€” one large CSV could flood concurrent Lambda invocations.

So I abandoned the direct-trigger idea.

---

## ğŸ’¡ Second Design â€“ Two Queues (RawEvents + Transactions)

I re-architected everything around two queues to fully decouple ingestion from scoring:

```
S3 (RawEventsBucket)
   â†’ SQS (RawEventsQueue)
       â†’ Lambda (BatchIngest)
           â†’ SQS (TransactionsQueue)
               â†’ Lambda (ScoreFunction)
```

This new design separated ingestion, processing, and scoring.
It also solved the circular dependency and gave me natural buffering and retries via SQS.

---

## ğŸ§© Debug Journey (Chronological)

### 1ï¸âƒ£ Setting up S3 â†’ SQS notification

I added this section to connect my raw bucket to the first queue:

```yaml
NotificationConfiguration:
  QueueConfigurations:
    - Event: s3:ObjectCreated:*
      Queue: !GetAtt RawEventsQueue.Arn
      Filter:
        S3Key:
          Rules:
            - Name: prefix
              Value: inbox/
            - Name: suffix
              Value: .csv
```

**Problem:**
Deployment failed with messages like:

> â€œDestination is not validâ€
> â€œUnable to validate destination ARNâ€

I tried adding `DependsOn`, but that caused circular dependencies again.
CloudFormation couldnâ€™t resolve the order because both resources referenced each other.

---

### 2ï¸âƒ£ Understanding the root cause

I discovered that when S3 configures an event destination, it doesnâ€™t just store the ARN â€” it actually *sends a test message* to the target SQS queue to verify permissions.
Since my queue was **KMS-encrypted**, S3 also needed to use the KMS key to generate and encrypt that test message.

At that point, my queue had this property:

```yaml
KmsMasterKeyId: !Ref AppDataKey
```

but my KMS key policy didnâ€™t allow S3 to call `kms:GenerateDataKey` or `kms:Decrypt`.
So validation failed.

---

### 3ï¸âƒ£ Fixing the KMS permissions

I realized S3 needed explicit access to use my CMK.
The right policy statement looked like this:

```yaml
- Sid: AllowS3ToUseKey
  Effect: Allow
  Principal:
    Service: s3.amazonaws.com
  Action:
    - kms:GenerateDataKey
    - kms:Decrypt
  Resource: "*"
  Condition:
    StringEquals:
      aws:SourceAccount: !Sub ${AWS::AccountId}
```

Once I added this, CloudFormation was finally able to create the notification configuration successfully.

---

### 4ï¸âƒ£ The mysterious â€œtest messagesâ€

When deployment finally succeeded, my **BatchIngest Lambda** started receiving unexpected SQS messages like:

```json
{
  "Service": "Amazon S3",
  "Event": "s3:TestEvent",
  "Time": "...",
  "Bucket": "...",
  "RequestId": "...",
  "HostId": "..."
}
```

These werenâ€™t real uploads.
They were *S3â€™s validation test events* â€” automatically sent every time a notification is created or updated.

My Lambda crashed with:

> `Invalid event structure: missing 'Records'`

So I added a guard clause to skip these messages:

```python
if "Records" not in s3_event:
    continue
```

After that, my Lambda started processing real upload events correctly.

---

### 5ï¸âƒ£ Fixing the queue policy

Even with permissions fixed, I still needed to explicitly allow S3 to send messages to the queue.
I added the following **QueuePolicy**:

```yaml
RawEventsQueuePolicy:
  Type: AWS::SQS::QueuePolicy
  Properties:
    Queues:
      - !Ref RawEventsQueue
    PolicyDocument:
      Version: "2012-10-17"
      Statement:
        - Sid: AllowS3SendMessage
          Effect: Allow
          Principal: { Service: "s3.amazonaws.com" }
          Action: "sqs:SendMessage"
          Resource: !GetAtt RawEventsQueue.Arn
          Condition:
            ArnLike:
              aws:SourceArn: !Sub arn:aws:s3:::${RawEventsBucket}
            StringEquals:
              aws:SourceAccount: !Sub ${AWS::AccountId}
```

Those two conditions were the key:

* `ArnLike` restricts messages to my specific bucket.
* `SourceAccount` ensures they come only from my AWS account.

Without these, S3â€™s test events were â€œacceptedâ€ but real events were rejected.
After adding this, I started getting real S3 notifications containing `"Records"`.

---

### 6ï¸âƒ£ Verifying the Lambda triggers

I also learned that the **`Events`** section under each Lambda behaves differently depending on whatâ€™s triggering it.
For example:

* `Type: SQS` â†’ expects `Queue` and `BatchSize`.
* `Type: S3` â†’ expects `Bucket`, `Events`, and `Filter`.
* `Type: Api` â†’ expects `Path` and `Method`.

That helped me understand why earlier my Lambda wasnâ€™t being triggered â€” I had mismatched properties under `Events:`.

---

## âœ… Final Working Architecture

```
S3 (RawEventsBucket)
  â†’ SQS (RawEventsQueue)
    â†’ Lambda: BatchIngest
      â†’ SQS (TransactionsQueue)
        â†’ Lambda: ScoreFunction
```

**Flow:**

1. I upload a CSV under `RawEventsBucket/inbox/`.
2. S3 sends an event to `RawEventsQueue`.
3. `BatchIngest` consumes it, downloads the CSV, validates rows, sends each transaction to `TransactionsQueue`, and writes receipts + processed files to `RefinedEventsBucket`.
4. `ScoreFunction` consumes messages from `TransactionsQueue`, scores them, writes to DynamoDB, and publishes alerts to SNS.

**Security and reliability layers:**

* All buckets and queues KMS-encrypted.
* Explicit KMS permissions for S3, SQS, and Lambda.
* IAM roles with least privilege.
* QueuePolicy linking S3 â†’ SQS.
* HTTPS-only bucket policies.
* Separate buckets (`Raw` vs `Refined`) to prevent re-triggering.

---

## ğŸ§  Lessons I Learned

1. **S3 validates destinations** by sending a test message when configuring notifications.
   If the queue is KMS-encrypted, S3 needs `kms:GenerateDataKey` and `kms:Decrypt` permissions.

2. **QueuePolicy is mandatory** â€” without it, S3 cannot publish events even if the KMS permissions are right.

3. **`ArnLike` and `SourceAccount`** are required to make S3 events pass validation and prevent cross-account issues.

4. **CloudFormation circular dependencies** occur when a resource both references and modifies another that depends on it.
   I avoided this by separating roles and using queues as decoupling layers.

5. **SAM `Events` syntax changes** with each trigger type â€” understanding this saved me hours.

6. **S3 â†’ SQS â†’ Lambda** fan-out pattern is much more reliable than direct triggers.
   It absorbs traffic spikes and gives me retries, isolation, and buffering.

7. **Always check test messages** â€” not every event in SQS is real data. S3 test events must be filtered out.

---

## ğŸ Final Status

âœ… Deployment successful
âœ… Uploads trigger ingestion automatically
âœ… BatchIngest parses and forwards transactions
âœ… ScoreFunction executes risk logic and publishes alerts
âœ… Receipts and processed files land in RefinedEventsBucket
âœ… Full encryption, no recursion, clean logs



     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚   RawEventsBucket (S3)   â”‚
     â”‚  inbox/*.csv uploads     â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚  Event Notification
                   â–¼
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚  RawEventsQueue (SQS)    â”‚
     â”‚  Encrypted w/ AppDataKey â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚  Trigger
                   â–¼
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ BatchIngestFunction      â”‚
     â”‚  - Reads CSVs            â”‚
     â”‚  - Sends txns â†’ SQS      â”‚
     â”‚  - Writes receipts       â”‚
     â”‚  - Moves files to        â”‚
     â”‚    RefinedEventsBucket   â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ TransactionsQueue (SQS)  â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚ Trigger
                   â–¼
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ ScoreFunction (Lambda)   â”‚
     â”‚ - Scores transactions    â”‚
     â”‚ - Writes results to      â”‚
     â”‚   DynamoDB               â”‚
     â”‚ - Publishes alerts â†’ SNS â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ RefinedEventsBucket (S3) â”‚
     â”‚ - Receipts & processed   â”‚
     â”‚   files                  â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

             â”‚
             â–¼
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ AlertsTopic (SNS)        â”‚
     â”‚ - High-risk notificationsâ”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

-----------------------------------------------------------------------------------


                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚     fraudmini system        â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                1. RawEventsBucket (S3)                 â”‚
â”‚  - KMS-encrypted with AppDataKey                       â”‚
â”‚  - Event: ObjectCreated:* on inbox/*.csv               â”‚
â”‚  - Sends notification to RawEventsQueue (SQS)          â”‚
â”‚                                                        â”‚
â”‚  BucketPolicy:                                         â”‚
â”‚    - Deny insecure transport                           â”‚
â”‚    - Enforce KMS encryption on PUT                     â”‚
â”‚                                                        â”‚
â”‚  KMS Policy:                                           â”‚
â”‚    - Allows S3 to GenerateDataKey + Decrypt            â”‚
â”‚                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â”‚  (S3 â†’ SQS Notification)
                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                2. RawEventsQueue (SQS)                 â”‚
â”‚  - KMS-encrypted (AppDataKey)                          â”‚
â”‚  - QueuePolicy allows S3:s3.amazonaws.com to SendMessageâ”‚
â”‚    only from RawEventsBucket ARN + same AWS account     â”‚
â”‚                                                        â”‚
â”‚  Event Source for: BatchIngest Lambda                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â”‚  (SQS â†’ Lambda trigger)
                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                3. BatchIngestFunction (Lambda)         â”‚
â”‚  - Reads events from RawEventsQueue                    â”‚
â”‚  - Downloads CSV from RawEventsBucket                  â”‚
â”‚  - Validates & parses records                          â”‚
â”‚  - Sends each record â†’ TransactionsQueue (SQS)         â”‚
â”‚  - Writes receipts + copies to RefinedEventsBucket     â”‚
â”‚  - Deletes processed CSV from RawEventsBucket          â”‚
â”‚                                                        â”‚
â”‚  IAM Policy:                                           â”‚
â”‚    - s3:GetObject/DeleteObject on RawEventsBucket      â”‚
â”‚    - s3:PutObject on RefinedEventsBucket               â”‚
â”‚    - sqs:SendMessage on TransactionsQueue              â”‚
â”‚    - kms:Encrypt/Decrypt on AppDataKey                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â”‚  (SQS â†’ Lambda trigger)
                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                4. TransactionsQueue (SQS)              â”‚
â”‚  - Buffers parsed transactions                         â”‚
â”‚  - Event Source for ScoreFunction                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â”‚  (SQS â†’ Lambda trigger)
                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                5. ScoreFunction (Lambda)               â”‚
â”‚  - Processes transaction messages                      â”‚
â”‚  - Evaluates fraud/risk logic                          â”‚
â”‚  - Writes results to DynamoDB Tables                   â”‚
â”‚  - Publishes alerts to AlertsTopic (SNS)               â”‚
â”‚  - Uses AppDataKey for encryption/decryption            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                6. RefinedEventsBucket (S3)             â”‚
â”‚  - Receipts (.json) and processed copies (.csv)        â”‚
â”‚  - KMS-encrypted with AppDataKey                       â”‚
â”‚  - Not part of trigger chain â†’ prevents recursion      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                7. AlertsTopic (SNS)                    â”‚
â”‚  - Receives high-risk alerts from ScoreFunction        â”‚
â”‚  - Can later fan-out to email/SMS notifications        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
