┌────────────────────────────────────────────────────────────┐
│                   CloudFormation (CFN Layer)               │
│  • Reads template.yaml                                     │
│  • Creates resources (buckets, Lambdas, roles, etc.)       │
│  • Sees "Bucket: !Ref RawEventsBucket"                     │
│                                                            │
│  Attaches PolicyDocument JSON to that specific bucket      │
└────────────────────────────────────────────────────────────┘
                           │
                           │ (Stores JSON policy inside bucket metadata)
                           ▼
┌────────────────────────────────────────────────────────────┐
│           IAM Evaluation Layer                             |         │
│  • Every S3 API call passes through IAM                    │
│  • IAM reads the PolicyDocument inside the bucket          │
│  • Evaluates each Statement:                               │
│       - Principal: who is calling                          │
│       - Action: e.g. s3:GetObject                          │
│       - Resource: which ARN (bucket or object)             │
│       - Condition: e.g. aws:SecureTransport=false          │
│  • Decides Allow or Deny                                   │
└────────────────────────────────────────────────────────────┘
 ---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ----------

| Situation                   | What you use  | Example                                        |
| --------------------------- | ------------- | ---------------------------------------------- |
| Talking to CloudFormation   | Logical name  | `!Ref RawEventsBucket`                         |
| Talking to AWS CLI          | Physical name | `aws s3 ls s3://fraudmini-RawEventsBucket-...` |
| Writing IAM/S3/KMS policies | ARN           | `arn:aws:s3:::fraudmini-RawEventsBucket-*`     |

Why AWS designed it like this???

Because AWS must:

- Allow multiple layers of abstraction (template vs runtime)

- Keep resources unique globally

- Allow permissions across accounts and services via ARNs

So:
→ Logical names make templates reusable.
→ Physical names make real resources.
→ ARNs make permissions globally consistent.
 ---------- ---------- ---------- ---------- ---------- ---------- ----------

Simplified evaluation order for request to succeed (permission-wise)

1- Start with implicit deny (everything is denied by default).

2- Add any explicit Allows from IAM and resource policies.

3- If an explicit Deny appears anywhere → final Deny.

4- Final decision: the request is allowed only if both IAM and resource policies explicitly allow it, and no explicit Deny exists.

AWS always evaluates both:

- the identity-based policy (attached to the user or role), and

- any resource-based policy (attached to the resource, like an S3 bucket)
both sides must agree

-----------------  ---------- ---------- ---------- ---------- ---------- ----------

All newly created S3 buckets automatically enable Server-Side Encryption with S3-managed keys (SSE-S3) by default.
So , CloudTrail bucket is already encrypted with S3’s own key only not with my kms key

-----------------  ---------- ---------- ---------- ---------- ---------- ----------


Commands to check deployment:

> API_URL=$(aws cloudformation describe-stacks --stack-name fraudmini \
  --query "Stacks[0].Outputs[?OutputKey=='ApiUrl'].OutputValue" --output text)
> curl -s ${API_URL}/health

----

> aws kms list-aliases --query "Aliases[?AliasName=='alias/fraudmini-appdata']"

----

> RAW=$(aws cloudformation list-stack-resources --stack-name fraudmini \
  --query "StackResourceSummaries[?LogicalResourceId=='RawEventsBucket'].PhysicalResourceId" --output text)

# should FAIL - no encryption header
> echo "should-fail" > /tmp/nope.txt
> aws s3api put-object --bucket "$RAW" --key test/nope.txt --body /tmp/nope.txt || echo "Expected AccessDenied"

# should SUCCEED with KMS
> KMS_ARN=$(aws kms list-aliases --query "Aliases[?AliasName=='alias/fraudmini-appdata'].TargetKeyId" --output text \
  | xargs -I{} aws kms describe-key --key-id {} --query "KeyMetadata.Arn" --output text)
> echo "hello" > /tmp/ok.txt
> aws s3api put-object --bucket "$RAW" --key test/ok.txt --body /tmp/ok.txt \
  --server-side-encryption aws:kms --ssekms-key-id "$KMS_ARN"

----

> aws cloudformation describe-stacks --stack-name fraudmini \
 --query "Stacks[0].Outputs[].[OutputKey,OutputValue]" --output table

 ----

> aws cloudtrail get-trail-status --name fraudmini-trail

 ** check stack status when it's rolling back etc by "StackStatus" here: `aws cloudformation describe-stacks --stack-name fraudmini --region eu-west-2`

 AN INCIDENT OCCURED:

What happened :

- CloudTrail checks the S3 bucket policy during creation.
It only accepts two exact Allow statements (GetBucketAcl and PutObject with the ACL condition).

- I had an extra Deny rule (DenyInsecureTransport), so CloudTrail’s validation failed — even though the logic was correct.

- After creation, CloudTrail stops validating the bucket policy, so I could safely add extra rules later.

- I removed the Deny temporarily -> deployed -> CloudTrail passed validation -> Trail created -> then I re-added the Deny rule -> deployed

----

> aws cloudformation describe-stacks --stack-name fraudmini \
 --query "Stacks[0].Outputs[].[OutputKey,OutputValue]" --output table

----

> python scripts/seed_rules.py

> RULES=$(aws cloudformation describe-stacks --stack-name fraudmini \
  --query "Stacks[0].Outputs[?OutputKey=='RulesTableName'].OutputValue" --output text)

> aws dynamodb scan --table-name "$RULES" --max-items 20 | jq '.Items'

----

sam build && sam deploy

API_URL=$(aws cloudformation describe-stacks --stack-name fraudmini \
  --query "Stacks[0].Outputs[?OutputKey=='ApiUrl'].OutputValue" --output text)

#  Valid body  501 (because it is schema-only rn)
# Expect: HTTP/1.1 501
curl -i -s -X POST "${API_URL}/score" \
  -H "Content-Type: application/json" \
  -d '{"transaction_id":"txn_1","user_id":"u_1","amount":12.3,"currency":"GBP","merchant_id":"m_AMZ","channel":"card_not_present","ts":"2025-09-29T08:15:13Z","ip":"81.2.69.142","country":"GB","device_id":"dev_1","card_bin":"400000","card_last4":"4242","attempts_last_10min":1}'



# Invalid body (missing required)  400 before Lambda
# Expect: HTTP/1.1 400
curl -i -s -X POST "${API_URL}/score" \
  -H "Content-Type: application/json" \
  -d '{"transaction_id":"txn_bad","amount":-5}'


