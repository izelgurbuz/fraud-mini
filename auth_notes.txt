CognitoUserPool:
  Type: AWS::Cognito::UserPool
  Properties:
    UserPoolName: fraudmini-userpool
    Schema:
      - Name: email
        Required: true
        Mutable: false
    AutoVerifiedAttributes: [ email ]
    Policies:
      PasswordPolicy:
        MinimumLength: 8
        RequireLowercase: true
        RequireNumbers: true
        RequireSymbols: false
        RequireUppercase: true

# 1 Frontend client — for users (email + password login)
CognitoFrontendClient:
  Type: AWS::Cognito::UserPoolClient
  Properties:
    UserPoolId: !Ref CognitoUserPool
    ClientName: fraudmini-frontend
    GenerateSecret: false          # public client — no secret in browser
    ExplicitAuthFlows:
      - ALLOW_USER_PASSWORD_AUTH
      - ALLOW_REFRESH_TOKEN_AUTH
    SupportedIdentityProviders: [COGNITO]

# 2 Backend client — for microservices (machine login)
CognitoBackendClient:
  Type: AWS::Cognito::UserPoolClient
  Properties:
    UserPoolId: !Ref CognitoUserPool
    ClientName: fraudmini-backend
    GenerateSecret: true           # private client — secret stored securely
    AllowedOAuthFlowsUserPoolClient: true
    AllowedOAuthFlows: [client_credentials]
    AllowedOAuthScopes:
      - https://fraudmini/api.read
      - https://fraudmini/api.write


>**** Two app clients = two ways to log in:

Frontend: users authenticate with email+password.

Backend: services authenticate with client ID + secret (no human).

Both share the same user pool, but each has its own login flow and security boundary.

>***** Frontend tokens represent users — they’re scoped to user-level actions and are short-lived.
Backend tokens represent the application itself — they can perform system-level operations like batch writes, monitoring, or calling internal APIs.

That’s why the backend client uses its own secret and OAuth scopes: it has capabilities that normal users should never have.


Get IDs:

> POOL_ID=$(aws cloudformation describe-stacks --stack-name fraudmini \
  --query "Stacks[0].Outputs[?OutputKey=='CognitoUserPoolId'].OutputValue" --output text)
> CLIENT_ID=$(aws cloudformation describe-stacks --stack-name fraudmini \
  --query "Stacks[0].Outputs[?OutputKey=='CognitoAppClientId'].OutputValue" --output text)
echo $POOL_ID
echo $CLIENT_ID


Create user + set password:

> aws cognito-idp admin-create-user \
  --user-pool-id "$POOL_ID" \
  --username demo@example.com \
  --user-attributes Name=email,Value=demo@example.com \
  --message-action SUPPRESS

> aws cognito-idp admin-set-user-password \
  --user-pool-id "$POOL_ID" \
  --username demo@example.com \
  --password 'Passw0rd!' \
  --permanent


Get a JWT (ID token):

> ID_TOKEN=$(aws cognito-idp initiate-auth \
  --auth-flow USER_PASSWORD_AUTH \
  --client-id "$CLIENT_ID" \
  --auth-parameters USERNAME=demo@example.com,PASSWORD='Passw0rd!' \
  --query 'AuthenticationResult.IdToken' --output text)
echo ${ID_TOKEN:0:40}

Call without token (should be 401):

> curl -i -s -X POST "${API_URL}/score" \
  -H "Content-Type: application/json" \
  --data-binary @txn.json 
# HTTP/1.1 401 Unauthorized


Call with token (should pass auth → 501 mock):

> curl -i -s -X POST "${API_URL}/score" \
  -H "Authorization: Bearer $ID_TOKEN" \
  -H "Content-Type: application/json" \
  --data-binary @txn.json